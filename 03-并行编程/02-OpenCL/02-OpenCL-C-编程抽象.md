# OpenCL C 编程抽象

## 上节课知识回顾

1. 平台（Platform）
2. 设备（Device）
3. 上下文（Context）
4. 存储（Memory）
5. 队列（Queue）
6. 事件（Event）

## 本节课内容

### 1 执行模型

#### 1.1 主机与设备分工

- **主机端程序**：负责 OpenCL 初始化、内核管理、任务提交与数据传输；
- **设备端内核程序**：运行在设备上的并行计算代码，由 OpenCL C 编写；

#### 1.2 数据传输

- **主机到设备**：通过 SVM（共享虚拟内存），直接映射设备内存到主机地址空间，可以避免显式的拷贝操作，提供更高效的内存共享；
- **设备到主机**：SVM 允许主机直接访问设备上的数据，避免了不必要的数据拷贝，提高了性能；
- **优化**：
  - 利用局部内存（Local Memory）；
  - 减少不必要的传输操作；

#### 1.3 NDRange

- OpenCL 通过 NDRange（索引空间）管理工作项；
  - **全局范围**：所有工作项总数；
  - **局部范围**：工作组大小；
  - **偏移量**：索引起点；

#### 1.4 工作项与工作组

- **工作项（Work-item）**：最小执行单元；
- **工作组（Work-group）**：工作项的集合；
- **全局 ID 和 局部 ID**
  - **公式**：`全局 ID = 工作组 ID × 工作组大小 + 局部 ID`；

### 2 编程模型

#### 2.1 数据并行模型

- 同一逻辑操作处理多个数据元素；
- 映射到 NDRange 并行执行；
- 同步
  - **组内同步**：`barrier()` 确保局部数据共享一致性；
  - **组间同步**：需由主机端逻辑控制；

#### 2.2 任务并行模型

- 各任务在不同工作项中执行不同操作；
- 适用于独立任务；

### 3 例：向量加法——从串行到并行的实现

为了帮助理解并行编程的概念，我们以向量加法为例，逐步展示如何从串行实现扩展到多线程，并最终利用 OpenCL 实现真正的并行计算。
